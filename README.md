# Домашнее задание: «Базы данных, их типы» - **Шаров Олег**

## Задание 1. СУБД

### 1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков

**Рекомендуемый тип СУБД:** Реляционная СУБД (SQL) — например, **PostgreSQL** или **Microsoft SQL Server**.

Финансовые данные требуют строгой схемы, ACID-гарантий(атомарность, согласованность, изолированность, долговечность), целостности ссылок и точных агрегаций. Реляционные СУБД отлично подходят для OLAP-нагрузок(онлайн-аналитической обработки), особенно при использовании материализованных представлений, индексов и поддержки оконных функций.

#### 1.1.* Хеширование стало занимать длительное время — какое API можно использовать для ускорения?

Для ускорения хеширования можно использовать:
- **Redis** — для кэширования промежуточных хешей,
- **BLAKE3** или другие высокопроизводительные библиотеки хеширования через соответствующие API,
- Внутри PostgreSQL — **C-расширения** или **PL/Python** для ускорения вычислений,

---

### 1.2. Лендинги и CRM

**Рекомендуемый тип СУБД:** Документоориентированная NoSQL (например, **MongoDB**) — но оптимальнее использовать **PostgreSQL с JSONB**.

Лендинги генерируют разнородные данные, а CRM требует гибкости. PostgreSQL с колонкой типа `JSONB` даёт гибкость NoSQL и надёжность SQL в одной системе.

#### 1.2.* Можно ли закрыть задачу одной СУБД?

**Да.** Использовать **PostgreSQL с JSONB**: лиды хранятся в JSON-поле, CRM работает с реляционными таблицами и теми же данными. Поддержка GIN-индексов обеспечивает высокую скорость поиска.

---

### 1.3. База знаний по корпоративным нормам

**Рекомендуемый тип СУБД:** Простая реляционная СУБД — например, **PostgreSQL** или даже **SQLite**.

Структура статичная и иерархическая. Не требуется высокая нагрузка.

#### 1.3.* Можно ли использовать существующую СУБД?

**Да.** Если используется PostgreSQL (из п. 1.1 или 1.2), базу знаний можно реализовать в ней же: таблица с полями `id`, `parent_id`, `title`, `content`. Полноценный поиск — через `tsvector`.

---

### 1.4. Логистика: маршруты и доставка

**Рекомендуемый тип СУБД:** Графовая СУБД — например, **Neo4j**.

Задача — работа со связями и поиск кратчайших путей. Графовые СУБД делают это на порядки эффективнее реляционных.

#### 1.4.* Подключить отдел закупок?

Закупки — транзакционные данные, плохо ложатся на графы. Лучше хранить их в **PostgreSQL**, а в Neo4j — только логистические сущности, связывая через внешние ID. Альтернатива — использовать **pgRouting** или **Apache AGE** внутри PostgreSQL.

---

### 1.5.* Можно ли всё решить одной СУБД?

**Технически — да (PostgreSQL), но нецелесообразно.**

PostgreSQL может покрыть все сценарии благодаря:
- Реляционной модели (финансы),
- JSONB (лиды/CRM),
- `tsvector` (база знаний),
- PostGIS + pgRouting / Apache AGE (логистика).

**Однако** графовые операции будут медленнее, чем в Neo4j, а архитектура станет сложной.

**Вывод:** Использовать **полиглотную персистентность**:
- **PostgreSQL** — финансы, CRM, база знаний,
- **Neo4j** — логистика.

Это обеспечит максимальную эффективность и масштабируемость.



## Задание 2. Транзакции

### 2.1. Пополнение баланса счёта телефона: пошаговый процесс успешной транзакции

Для обеспечения целостности данных и корректного выполнения операции пополнения баланса необходимо выполнить следующие **шесть действий** в рамках одной транзакции:

1. **Аутентификация и авторизация пользователя**  
   Система проверяет, что пользователь имеет право инициировать платёж (например, через вход в личный кабинет).

2. **Блокировка средств на счёте источника**  
   На банковском счёте, карте или электронном кошельке пользователя резервируются средства в размере суммы пополнения (чтобы избежать двойного списания при параллельных запросах).

3. **Проверка корректности реквизитов получателя**  
   Система убеждается, что указанный номер телефона существует, активен и принадлежит поддерживаемому оператору связи.

4. **Списание средств с источника**  
   После всех проверок деньги окончательно списываются с платёжного инструмента пользователя.

5. **Зачисление средств на телефонный счёт**  
   Баланс абонента увеличивается на сумму пополнения в базе данных оператора связи.

6. **Фиксация транзакции и отправка уведомления**  
   Все изменения подтверждаются, создаётся запись в журнале операций, и пользователю отправляется SMS/пуш-уведомление об успешном пополнении.

> Если на любом этапе возникает ошибка (недостаточно средств, недействительный номер и т.д.), транзакция откатывается (rollback), и все изменения отменяются — баланс остаётся неизменным.

### 2.1.* Пополнение через автоплатёж

Если пополнение происходит **автоматически по расписанию** (автоплатёж), добавляются следующие особенности:

- **Предварительная настройка**: пользователь заранее даёт согласие на регулярные списания, указывает сумму, дату и платёжный метод.
- **Фоновая инициация**: система запускает транзакцию без участия пользователя (например, 1-го числа каждого месяца).
- **Упрощённая аутентификация**: вместо логина используется **токен доверия** или **сохранённые учётные данные**.
- **Повышенные требования к идемпотентности**: если платёж был частично выполнен (например, из-за сетевого сбоя), повторная попытка не должна привести к двойному списанию.
- **Обработка отказов**: при неудаче (например, просроченная карта) система может:
  - сделать несколько повторных попыток,
  - отправить уведомление пользователю,
  - приостановить автоплатёж до обновления данных.

Остальные шаги (резервирование, списание, зачисление, фиксация) остаются теми же, но выполняются **в фоновом режиме** и должны быть максимально отказоустойчивыми.



