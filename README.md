# Домашнее задание: «Базы данных, их типы» - **Шаров Олег**

## Задание 1. СУБД

### 1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков

**Рекомендуемый тип СУБД:** Реляционная СУБД (SQL) — например, **PostgreSQL** или **Microsoft SQL Server**.

Финансовые данные требуют строгой схемы, ACID-гарантий(атомарность, согласованность, изолированность, долговечность), целостности ссылок и точных агрегаций. Реляционные СУБД отлично подходят для OLAP-нагрузок(онлайн-аналитической обработки), особенно при использовании материализованных представлений, индексов и поддержки оконных функций.

#### 1.1.* Хеширование стало занимать длительное время — какое API можно использовать для ускорения?

Для ускорения хеширования можно использовать:
- **Redis** — для кэширования промежуточных хешей,
- **BLAKE3** или другие высокопроизводительные библиотеки хеширования через соответствующие API,
- Внутри PostgreSQL — **C-расширения** или **PL/Python** для ускорения вычислений,

---

### 1.2. Лендинги и CRM

**Рекомендуемый тип СУБД:** Документоориентированная NoSQL (например, **MongoDB**) — но оптимальнее использовать **PostgreSQL с JSONB**.

Лендинги генерируют разнородные данные, а CRM требует гибкости. PostgreSQL с колонкой типа `JSONB` даёт гибкость NoSQL и надёжность SQL в одной системе.

#### 1.2.* Можно ли закрыть задачу одной СУБД?

**Да.** Использовать **PostgreSQL с JSONB**: лиды хранятся в JSON-поле, CRM работает с реляционными таблицами и теми же данными. Поддержка GIN-индексов обеспечивает высокую скорость поиска.

---

### 1.3. База знаний по корпоративным нормам

**Рекомендуемый тип СУБД:** Простая реляционная СУБД — например, **PostgreSQL** или даже **SQLite**.

Структура статичная и иерархическая. Не требуется высокая нагрузка.

#### 1.3.* Можно ли использовать существующую СУБД?

**Да.** Если используется PostgreSQL (из п. 1.1 или 1.2), базу знаний можно реализовать в ней же: таблица с полями `id`, `parent_id`, `title`, `content`. Полноценный поиск — через `tsvector`.

---

### 1.4. Логистика: маршруты и доставка

**Рекомендуемый тип СУБД:** Графовая СУБД — например, **Neo4j**.

Задача — работа со связями и поиск кратчайших путей. Графовые СУБД делают это на порядки эффективнее реляционных.

#### 1.4.* Подключить отдел закупок?

Закупки — транзакционные данные, плохо ложатся на графы. Лучше хранить их в **PostgreSQL**, а в Neo4j — только логистические сущности, связывая через внешние ID. Альтернатива — использовать **pgRouting** или **Apache AGE** внутри PostgreSQL.

---

### 1.5.* Можно ли всё решить одной СУБД?

**Технически — да (PostgreSQL), но нецелесообразно.**

PostgreSQL может покрыть все сценарии благодаря:
- Реляционной модели (финансы),
- JSONB (лиды/CRM),
- `tsvector` (база знаний),
- PostGIS + pgRouting / Apache AGE (логистика).

**Однако** графовые операции будут медленнее, чем в Neo4j, а архитектура станет сложной.

**Вывод:** Использовать **полиглотную персистентность**:
- **PostgreSQL** — финансы, CRM, база знаний,
- **Neo4j** — логистика.

Это обеспечит максимальную эффективность и масштабируемость.



## Задание 2. Транзакции

### 2.1. Пополнение баланса счёта телефона: пошаговый процесс успешной транзакции

Для обеспечения целостности данных и корректного выполнения операции пополнения баланса необходимо выполнить следующие **шесть действий** в рамках одной транзакции:

1. **Аутентификация и авторизация пользователя**  
   Система проверяет, что пользователь имеет право инициировать платёж (например, через вход в личный кабинет).

2. **Блокировка средств на счёте источника**  
   На банковском счёте, карте или электронном кошельке пользователя резервируются средства в размере суммы пополнения (чтобы избежать двойного списания при параллельных запросах).

3. **Проверка корректности реквизитов получателя**  
   Система убеждается, что указанный номер телефона существует, активен и принадлежит поддерживаемому оператору связи.

4. **Списание средств с источника**  
   После всех проверок деньги окончательно списываются с платёжного инструмента пользователя.

5. **Зачисление средств на телефонный счёт**  
   Баланс абонента увеличивается на сумму пополнения в базе данных оператора связи.

6. **Фиксация транзакции и отправка уведомления**  
   Все изменения подтверждаются, создаётся запись в журнале операций, и пользователю отправляется SMS/пуш-уведомление об успешном пополнении.

> Если на любом этапе возникает ошибка (недостаточно средств, недействительный номер и т.д.), транзакция откатывается (rollback), и все изменения отменяются — баланс остаётся неизменным.

### 2.1.* Пополнение через автоплатёж

Если пополнение происходит **автоматически по расписанию** (автоплатёж), добавляются следующие особенности:

- **Предварительная настройка**: пользователь заранее даёт согласие на регулярные списания, указывает сумму, дату и платёжный метод.
- **Фоновая инициация**: система запускает транзакцию без участия пользователя (например, 1-го числа каждого месяца).
- **Упрощённая аутентификация**: вместо логина используется **токен доверия** или **сохранённые учётные данные**.
- **Повышенные требования к идемпотентности**: если платёж был частично выполнен (например, из-за сетевого сбоя), повторная попытка не должна привести к двойному списанию.
- **Обработка отказов**: при неудаче (например, просроченная карта) система может:
  - сделать несколько повторных попыток,
  - отправить уведомление пользователю,
  - приостановить автоплатёж до обновления данных.

Остальные шаги (резервирование, списание, зачисление, фиксация) остаются теми же, но выполняются **в фоновом режиме** и должны быть максимально отказоустойчивыми.




## Задание 3. SQL vs NoSQL

### 3.1. Пять преимуществ SQL-систем по отношению к NoSQL

1. **Строгая целостность данных (ACID)**  
   Реляционные СУБД гарантируют атомарность, согласованность, изолированность и долговечность транзакций. Это критично для финансовых, бухгалтерских и других систем, где ошибка недопустима.

2. **Чёткая схема данных (Schema-on-write)**  
   Заранее определённая структура таблиц предотвращает неконсистентность данных, упрощает проектирование, документирование и поддержку приложений.

3. **Мощный декларативный язык запросов (SQL)**  
   SQL позволяет выполнять сложные аналитические запросы — JOIN’ы, агрегации, оконные функции, рекурсивные CTE — без необходимости обработки данных на стороне приложения.

4. **Зрелая экосистема и инструменты**  
   SQL-СУБД (PostgreSQL, MySQL, Oracle и др.) имеют десятилетия развития: надёжные репликация, резервное копирование, мониторинг, GUI-инструменты, ORM-поддержку и огромное сообщество.

5. **Поддержка сложных связей между сущностями**  
   Благодаря внешним ключам и нормализованной структуре, SQL идеально подходит для моделей с множеством взаимосвязей (например, ERP, CRM, учётные системы).

### 3.1.* Преимущества NewSQL-систем перед SQL и NoSQL

**NewSQL** — это новый класс СУБД, сочетающий **масштабируемость NoSQL** с **ACID-гарантиями и SQL-интерфейсом классических реляционных систем**.

Ключевые преимущества:

- ✅ **Горизонтальная масштабируемость «из коробки»**  
  В отличие от традиционных SQL-СУБД (где масштабирование часто вертикальное), NewSQL (например, **CockroachDB**, **TiDB**, **Google Spanner**) автоматически распределяет данные по узлам кластера.

- ✅ **Полная поддержка ACID на уровне распределённой системы**  
  Даже при отказе части узлов сохраняется согласованность — чего нет в большинстве NoSQL-решений (AP-системы по теореме CAP).

- ✅ **Привычный SQL-интерфейс**  
  Разработчики не вынуждены отказываться от мощи SQL или переписывать логику при переходе с PostgreSQL/MySQL.

- ✅ **Автоматическое управление шардами и репликами**  
  Нет необходимости вручную настраивать партиционирование или балансировку — система делает это сама.

- ✅ **Высокая доступность и отказоустойчивость**  
  Данные реплицируются синхронно между регионами, обеспечивая непрерывность работы даже при потере целого дата-центра.

> **Итог:** NewSQL — лучший выбор для современных облачных приложений, которым нужны **надёжность SQL + масштабируемость NoSQL**, особенно в сферах fintech, e-commerce и SaaS.




## Задание 4. Кластеры

При наличии **1000 выделенных машин** и задачи, связанной с **большим объёмом данных и интенсивными вычислениями**, выбор СУБД и модели распределённых вычислений должен основываться на следующем ключевом критерии:

> **Способность системы эффективно масштабироваться горизонтально, минимизировать сетевой оверхед и выполнять параллельную обработку данных локально на каждом узле.**

### Критерий выбора типа СУБД

**Модель обработки данных (OLAP vs OLTP) и характер нагрузки.**  
Поскольку речь идёт о «большом количестве вычислений» над «огромным количеством данных», это типичная **аналитическая (OLAP)** или **batch-обрабатывающая** задача, а не транзакционная (OLTP). Приоритет — не целостность отдельных записей, а **пропускная способность, скорость сканирования и параллелизм**.

Поэтому **классические реляционные СУБД (PostgreSQL, MySQL)** не подходят — они плохо масштабируются на тысячи узлов.  
**NoSQL-решения (MongoDB, Cassandra)** лучше масштабируются, но не оптимизированы под сложные аналитические запросы.

### Оптимальный выбор

**Рекомендуемая СУБД:**  
- **ClickHouse** — колоночная СУБД с векторизованными вычислениями, отлично масштабируется на сотни узлов, поддерживает distributed-таблицы и локальную предварительную агрегацию.  
- **Apache Druid** — для гибридных аналитических/временных запросов.  
- **Databricks / Apache Spark SQL** — если данные хранятся в объектном хранилище (S3, GCS).

**Рекомендуемая модель распределённых вычислений:**  
> **MapReduce / Data-Parallel Processing (MPP — Massively Parallel Processing)**

**Почему MPP?**  
- Данные **разделяются на части (шарды)** и распределяются по всем 1000 узлам.  
- Вычисления выполняются **локально на каждом узле** над своей частью данных («вычисления идут к данным»).  
- Промежуточные результаты агрегируются на координаторах или через shuffle-фазу.  
- Минимизируется передача данных по сети — главный узкий момент в распределённых системах.

**Примеры реализаций:**  
- **ClickHouse** использует собственную MPP-архитектуру с distributed-таблицами.  
- **Apache Spark** реализует DAG-модель вычислений поверх HDFS/S3, идеально подходит для ETL, ML и сложных трансформаций.  
- **Greenplum / Amazon Redshift** — классические MPP-СУБД.

### Вывод

Для задачи с 1000 машинами и большим объёмом вычислений:
- **Тип СУБД**: колоночная аналитическая СУБД (например, **ClickHouse**) или **Spark-based SQL движок**.
- **Модель вычислений**: **MPP (Massively Parallel Processing)** или **Data-Parallel (MapReduce-style)**.
- **Причина**: максимальное использование локальных ресурсов каждого узла, минимизация сетевого трафика, высокая пропускная способность и линейная масштабируемость.

> Такой подход используется в реальных системах: Yandex.Metrica (ClickHouse), Facebook (Presto + Hive), Netflix (Spark + S3).





